{"version":3,"file":"index.es.js","sources":["../src/helpers/utils_temp.js","../src/Maxbot/index.js"],"sourcesContent":["/**\n * FIXME: refactor to performance\n * @function prepareSendFilter\n * @param {import('../Maxbot/types/sending').IForWhoFilter} forWhoFilter\n */\nexport function prepareSendFilter(forWhoFilter) {\n  const { externalId, whatsapp, brCpf } = forWhoFilter\n  const result = {}\n  if (externalId) {\n    result.ctExternalId = externalId\n  } else if (whatsapp) {\n    result.ctWhatsapp = whatsapp\n  } else if (brCpf) {\n    result.ctBrCpf = brCpf\n  } else {\n    return false\n  }\n  return result\n}\n\n/**\n * Temporário até padronizar o endpoint\n * @function normalizeContactSegmentation\n * @param {string|string[]} segmentation\n * @returns {string}\n */\nexport function normalizeContactSegmentation(segmentation) {\n  if (segmentation && Array.isArray(segmentation)) {\n    return segmentation.filter(f => !!f).join(',')\n  }\n  return segmentation\n}\n","/**\n * @typedef {import('./types/types').MaxbotOptions} MaxbotOptions\n * @typedef {import('./types/types').ApiResult} ApiResult\n * @typedef {import('./types/types').ITemplateResult} ITemplateResult\n * @typedef {import('./types/types').IServiceSectorResult} IServiceSectorResult\n * @typedef {import('./types/types').IAttendantResult} IAttendantResult\n * @typedef {import('./types/types').PostType} PostType\n * @typedef {import('./types/types').IRequestPayload} IRequestPayload\n * @typedef {import('./types/types').ICancelSource} ICancelSource\n *\n * @typedef {import('./types/status').IGetStatusResult} IGetStatusResult\n * @typedef {import('./types/status').IStatusData} IStatusData\n * @typedef {import('./types/segmentation').ISegmentationData} ISegmentationData\n * @typedef {import('./types/segmentation').IGetSegmentationResult} IGetSegmentationResult\n * @typedef {import('./types/contact').IContactFilter} IContactFilter\n * @typedef {import('./types/contact').IContactData} IContactData\n * @typedef {import('./types/contact').ISetContactData} ISetContactData\n * @typedef {import('./types/contact').IPutContactData} IPutContactData\n * @typedef {import('./types/contact').IGetContactResult} IGetContactResult\n * @typedef {import('./types/protocol').IProtFilter} IProtFilter\n * @typedef {import('./types/protocol').IGetProtResult} IGetProtResult\n * @typedef {import('./types/sending').IForWhoFilter} IForWhoFilter\n * @typedef {import('./types/sending').ISendTextResult} ISendTextResult\n * @typedef {import('./types/serviceSector').IServiceSector} IServiceSector\n *\n * @typedef {import('axios').CancelTokenSource} CancelTokenSource\n * @typedef {import('axios').CancelToken} CancelToken\n *\n */\nimport axios from 'axios'\nimport camelcaseKeys from 'camelcase-keys'\nimport { onResponseError } from './api/onResponseError'\nimport { prepareSendFilter, normalizeContactSegmentation } from '../helpers/utils_temp'\nimport { extractExtension, replaceAll, isValidURL } from '../helpers'\nimport decamelcase from '../helpers/decamelcase'\nimport { version } from '../../package.json'\n\nconst postType = {\n  GETSTATUS: 'get_status',\n  GETSEGMENTATION: 'get_segmentation',\n  GETTEMPLATE: 'get_template',\n  GETSERVICESECTOR: 'get_service_sector',\n  GETATTENDANT: 'get_attendant',\n  GETCONTACT: 'get_contact',\n  GETPROT: 'get_prot',\n  PUTCONTACT: 'put_contact',\n  SETCONTACT: 'set_contact',\n  OPENFOLLOWUP: 'open_followup',\n  SENDTEXT: 'send_text',\n  SENDIMAGE: 'send_image',\n  SENDFILE: 'send_file',\n  SENDSOUND: 'send_sound'\n}\n\nconst baseURL = 'https://mbr.maxbot.com.br/api/v1.php'\n// const baseURL = 'http://localhost1:3003/test/hookhttp1'\n\n/**\n * @class\n * Class Maxbot methods:\n * - setMe\n * - getMe\n * - getStatus\n * - getSegmentation\n * - getTemplate\n * - getServiceSector\n * - getProt\n * - putContact\n * - setContact\n * - openFollowup\n * - sendText\n * - sendImage\n * - sendFile\n * - sendSound\n */\nclass Maxbot {\n  /**\n   * @constructor\n   * @param {MaxbotOptions} params\n   */\n  constructor(params) {\n    /** @type {MaxbotOptions} */\n    this.config = { token: '', timeout: 3000, baseURL, debug: false }\n    this.ready = false\n    this.loggingPrefix = 'MaxbotJs'\n    this.version = version\n    this.Api = axios.create()\n\n    /** @type {ICancelSource[]} */\n    this.cancelSources = []\n\n    /** @private */\n    this.allowedExt = {\n      file: ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'pps'],\n      image: ['jpg', 'jpeg', 'png', 'gif'],\n      sound: ['mp3']\n    }\n\n    return this.setMe(params).configureAxios()\n  }\n\n  log(...args) {\n    if (this.config.debug) {\n      // eslint-disable-next-line no-console\n      console.log(this.loggingPrefix, ...args, '\\n')\n    }\n  }\n\n  /**\n   * @private\n   * @method getCancelToken\n   */\n  getCancelToken() {\n    return axios.CancelToken\n  }\n\n  /**\n   * @private\n   * @method configureAxios\n   */\n  configureAxios() {\n    this.Api = axios.create({ baseURL: this.config.baseURL })\n    return this.configureRequests().configureResponses()\n  }\n\n  /**\n   * @private\n   * @method configureRequests\n   */\n  configureRequests() {\n    this.Api.interceptors.request.use(config => {\n      config.headers[\n        'user-agent'\n      ] = `maxbotjs/${this.version} (+https://github.com/leguass7/maxbotjs.git)`\n\n      config.data = decamelcase(config.data)\n      this.log('REQUEST:', config.data)\n      // this.log('REQUEST JOSN:', JSON.stringify(config.data))\n      return config\n    })\n    return this\n  }\n\n  /**\n   * @private\n   * @method configureRequests\n   */\n  configureResponses() {\n    this.Api.interceptors.response.use(response => {\n      this.log('RESPONSE:', response.data || response)\n      return camelcaseKeys(response.data, { deep: true })\n    }, onResponseError)\n    return this\n  }\n\n  /**\n   * @private\n   * @method addError\n   * @param {string} msg\n   */\n  addError(msg) {\n    return { status: 0, msg }\n  }\n\n  /**\n   * @method isValidExt\n   * @param {'file'|'image'|'sound'} type\n   * @param {string} ext\n   * @returns {boolean}\n   * @example\n   * maxbot.isValidExt('.exe', 'file') // false\n   * maxbot.isValidExt('.pdf', 'file') // true\n   * maxbot.isValidExt('pdf') // true\n   * maxbot.isValidExt('.png', 'image') // true\n   */\n  isValidExt(extension, type = '') {\n    const ext = replaceAll(extension, '.', '')\n    if (!type) {\n      const testAll = Object.keys(this.allowedExt).reduce((all, key) => {\n        this.allowedExt[key].forEach(e => all.push(e))\n        return all\n      }, [])\n      return testAll.includes(replaceAll(ext, '.', ''))\n    }\n    return !!this.allowedExt[type].includes(replaceAll(ext, '.', ''))\n  }\n\n  /**\n   * Verifica se bot esta pronto\n   * @method isReady\n   * @param {Boolean} force force api request status\n   * @returns {Promise<Boolean>}\n   */\n  async isReady(force = false) {\n    if (!this.config.token) return false\n    const check = async () => {\n      try {\n        const result = await this.getStatus()\n        return !!(result && result.status)\n      } catch (error) {\n        return false\n      }\n    }\n    if (force || !this.ready) this.ready = await check()\n    return !!this.ready\n  }\n\n  /**\n   * Configura\n   * @method setMe\n   * @param {MaxbotOptions|String} prop\n   * @param {Number|String|Function} value\n   * @returns {this}\n   */\n  setMe(prop, value) {\n    const { config } = this\n    if (typeof prop === 'object') {\n      const keys = Object.keys(prop)\n      for (let i = 0; i < keys.length; i++) {\n        if (keys[i] in config) config[keys[i]] = prop[keys[i]]\n      }\n    } else if (typeof prop === 'string') {\n      if (prop in config) config[prop] = typeof value === 'function' ? value() : value\n    }\n    return this\n  }\n\n  /**\n   * Adquiri configurações\n   * @method getMe\n   * @returns {MaxbotOptions}\n   */\n  getMe() {\n    return this.config\n  }\n\n  /**\n   * Verificar a situação atual da API Maxbot\n   * @method getStatus\n   * @returns {Promise<IGetStatusResult>}\n   */\n  async getStatus() {\n    const res = await this.requestApi(postType.GETSTATUS)\n    return res\n  }\n\n  /**\n   * Importar seguimentações do Maxbot\n   * @method getSegmentation\n   * @returns {Promise<IGetSegmentationResult>}\n   */\n  async getSegmentation() {\n    const res = await this.requestApi(postType.GETSEGMENTATION)\n    return res\n  }\n\n  /**\n   * Importar templates do Maxbot\n   * @method getTemplate\n   * @returns {Promise<ITemplateResult>}\n   */\n  async getTemplate() {\n    const res = await this.requestApi(postType.GETTEMPLATE)\n    return res\n  }\n\n  /**\n   * Importar service sectors do Maxbot\n   * @method getServiceSector\n   * @returns {Promise<IServiceSectorResult>}\n   */\n  async getServiceSector() {\n    const res = await this.requestApi(postType.GETSERVICESECTOR)\n    return res\n  }\n\n  /**\n   * Importar atendentes do Maxbot\n   * @method getAttendant\n   * @returns {Promise<IAttendantResult>}\n   */\n  async getAttendant() {\n    const res = await this.requestApi(postType.GETATTENDANT)\n    return res\n  }\n\n  /**\n   * Importar a ficha de cadastro do contato\n   * @method getContact\n   * @param {IContactFilter} filter\n   * @returns {Promise<IGetContactResult>}\n   */\n  async getContact(filter) {\n    const res = await this.requestApi(postType.GETCONTACT, filter)\n    return res\n  }\n\n  /**\n   * Importar os protocolos concluídos em um determinado período\n   * @method getProt\n   * @param {IProtFilter} filter\n   * @returns {Promise<IGetProtResult>}\n   */\n  async getProt(filter) {\n    const res = await this.requestApi(postType.GETPROT, filter)\n    return res\n  }\n\n  /**\n   * Criar um novo contato no Maxbot\n   * @method putContact\n   * @param {IPutContactData} contactData\n   * @returns {Promise<ApiResult>}\n   */\n  async putContact(contactData) {\n    if (contactData.segmentation) {\n      contactData.segmentation = normalizeContactSegmentation(contactData.segmentation)\n    }\n\n    const res = await this.requestApi(postType.PUTCONTACT, contactData)\n    return res\n  }\n\n  /**\n   * Atualizar dados de um contato existente\n   * @method setContact\n   * @param {ISetContactData} contactData\n   * @returns {Promise<ApiResult>}\n   */\n  async setContact(contactData) {\n    if (contactData.segmentation) {\n      contactData.segmentation = normalizeContactSegmentation(contactData.segmentation)\n    }\n    const res = await this.requestApi(postType.SETCONTACT, contactData)\n    return res\n  }\n\n  /**\n   * Abrir um followup do Maxbot\n   * @method openFollowup\n   * @param {IFollowupData} followupData\n   * @returns {Promise<ApiResult>}\n   */\n  async openFollowup(followupData) {\n    const res = await this.requestApi(postType.OPENFOLLOWUP, followupData)\n    return res\n  }\n\n  /**\n   * Envia uma mensagem de texto para um contato existente\n   * @method sendText\n   * @param {IForWhoFilter} forWho\n   * @param {String} text\n   * @returns {Promise<ISendTextResult>}\n   */\n  async sendText(forWho, text) {\n    const filter = prepareSendFilter(forWho)\n    if (!filter) return false\n    const payload = { ...filter, msg: text }\n    const res = await this.requestApi(postType.SENDTEXT, payload)\n    return res\n  }\n\n  /**\n   * Envia uma imagem para um contato existente\n   * @method sendImage\n   * @param {IForWhoFilter} forWho\n   * @param {String} urlImage\n   * @returns {Promise<ApiResult>}\n   */\n  async sendImage(forWho, urlImage) {\n    const filter = prepareSendFilter(forWho)\n    if (!filter) return this.addError('internal: no contact')\n    if (!isValidURL(urlImage)) return this.addError('internal: invalid url')\n\n    const imageExtension = extractExtension(urlImage)\n    if (!this.isValidExt(imageExtension, 'image')) {\n      return this.addError(`internal: invalid extension ${imageExtension}`)\n    }\n\n    const payload = { ...filter, imageUrl: urlImage, imageExtension }\n    const res = await this.requestApi(postType.SENDIMAGE, payload)\n    return res\n  }\n\n  /**\n   * Envia um arquivo para um contato existente\n   * @method sendFile\n   * @param {IForWhoFilter} forWho\n   * @param {String} urlFile\n   * @returns {Promise<ApiResult>}\n   */\n  async sendFile(forWho, urlFile) {\n    const filter = prepareSendFilter(forWho)\n    if (!filter) return this.addError('internal: no contact')\n    if (!isValidURL(urlFile)) return this.addError('internal: invalid url')\n\n    const fileExtension = extractExtension(urlFile)\n    if (!this.isValidExt(fileExtension, 'file')) {\n      return this.addError(`internal: invalid extension ${fileExtension}`)\n    }\n\n    const payload = { ...filter, fileUrl: urlFile, fileExtension }\n    const res = await this.requestApi(postType.SENDFILE, payload)\n    return res\n  }\n\n  /**\n   * Envia um audio para um contato existente\n   * @method sendSound\n   * @param {IForWhoFilter} forWho\n   * @param {String} urlSound\n   * @returns {Promise<ApiResult>}\n   */\n  async sendSound(forWho, urlSound) {\n    const filter = prepareSendFilter(forWho)\n    if (!filter) return this.addError('internal: no contact')\n    if (!isValidURL(urlSound)) return this.addError('internal: invalid url')\n\n    const soundExtension = extractExtension(urlSound)\n    if (!this.isValidExt(soundExtension, 'sound')) {\n      return this.addError(`internal: invalid extension ${soundExtension}`)\n    }\n\n    const payload = { ...filter, soundUrl: urlSound, soundExtension }\n    const res = await this.requestApi(postType.SENDSOUND, payload)\n    return res\n  }\n\n  /**\n   * @private\n   * @method requestApi\n   * @param {PostType} type\n   * @param {IRequestPayload} payload\n   * @returns {Promise<ApiResult>}\n   */\n\n  async requestApi(type, payload = {}) {\n    const self = this\n\n    const source = this.getCancelToken().source()\n    const cancelToken = source.token\n    this.addCancelSource(source)\n\n    const result = await this.Api.post(\n      null, // self.config.baseURL,\n      {\n        cmd: type,\n        token: self.config.token,\n        ...payload\n      },\n      {\n        timeout: self.config.timeout,\n        // baseURL: self.config.baseURL,\n        cancelToken\n      }\n    )\n\n    // if (result && typeof result === 'object' && !this.ready) this.ready = !!result.status\n\n    this.removeCancelSource(cancelToken)\n    return result\n  }\n\n  /**\n   * @private\n   * @method addCancelSource\n   * @param {CancelTokenSource} source\n   * @returns {this}\n   */\n  addCancelSource(source) {\n    this.cancelSources.push({\n      idToken: source.token,\n      source\n    })\n    return this\n  }\n\n  /**\n   * @private\n   * @method removeCancelSource\n   * @param {CancelToken|string} idTokenSource\n   * @returns {this}\n   */\n  removeCancelSource(idTokenSource) {\n    if (idTokenSource) {\n      const newList = this.cancelSources.filter(({ idToken }) => idToken !== idTokenSource)\n      this.cancelSources = newList || []\n      return this\n    }\n    this.cancelSources = []\n    return this\n  }\n\n  /**\n   * @method cancel\n   * @returns {this}\n   */\n  cancel() {\n    this.cancelSources.forEach(({ source }) => source && source.cancel())\n    this.removeCancelSource()\n    return this\n  }\n}\n\nexport default Maxbot\n"],"names":["prepareSendFilter","forWhoFilter","externalId","whatsapp","brCpf","result","ctExternalId","ctWhatsapp","ctBrCpf","normalizeContactSegmentation","segmentation","Array","isArray","filter","f","join","postType","Maxbot","constructor","params","config","token","timeout","baseURL","debug","ready","loggingPrefix","version","Api","axios","create","cancelSources","allowedExt","file","image","sound","this","setMe","configureAxios","log","args","console","getCancelToken","CancelToken","configureRequests","configureResponses","interceptors","request","use","headers","data","decamelcase","response","camelcaseKeys","deep","onResponseError","addError","msg","status","isValidExt","extension","type","ext","replaceAll","Object","keys","reduce","all","key","forEach","e","push","includes","force","async","getStatus","error","check","prop","value","i","length","getMe","requestApi","contactData","followupData","forWho","text","payload","urlImage","isValidURL","imageExtension","extractExtension","imageUrl","urlFile","fileExtension","fileUrl","urlSound","soundExtension","soundUrl","source","cancelToken","addCancelSource","post","cmd","removeCancelSource","idToken","idTokenSource","newList","cancel"],"mappings":"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"}